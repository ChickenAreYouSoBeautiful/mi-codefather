## MySQL by 睿智
**课程笔记链接**：https://frxcat.fun/database/MySQL/MySQL_Advanced_index/ 

##**存储引擎**

## MySql体系结构

**连接层**：最上层是一些客户端和链接服务，主要完成一些类似于链连接处理，认证授权，及相关的安全方案。服务器也会为安全接入每个客户端验证它所具有的操作权限

**服务层**：第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也再这一层实现，如 过程，函数等。

**引擎层**：存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同存储引擎具有不同的功能。这样我们可以根据自己的需要，来选取合适的搜索引擎

**存储层**：主要是将数据存储在文件系统之上，并完成与存储引擎的交互

## 存储引擎简介

存储引擎就是存储数据，建立索引，更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可以成为表类型

## 存储引擎特点

### innoDB

**介绍**：innoDB是一种兼顾高可靠和高性能的通用存储引擎，在MySQL5.5之后，innoDB是默认的MySQL引擎

**特点**：

1.DML操作遵循ACID模型，支持事务

2.行级锁，提高并发访问性能

3.支持外键 FORMEIGN KEY约束，保证数据的完成性和正确性

**文件**：xxx.idb：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm，sdi），数据和索引。

参数：innodb_file_per_table

# 索引

## 索引概述

**介绍**：索引（index）是帮助mysql高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引

**优缺点**：

优势：提高数据检索效率，降低数据库的io成本，通过索引列对数据进行排序，降低数据排序成本，降低cpu消耗

劣势：索引列也是要占用空间的，索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行insert，update，delete时，效率降低

## 索引结构

MySQL的索引时在存储引擎层实现的，不同的存储引擎有不同的结构，主要包含一下几种

### B+Tree 索引

最常见的索引类型，大部分引擎都支持B+Tree数索引

### Hash索引

底层数据结构是用哈希表实现的，只有精确汽配索引的列的查询才有效，不支持范围查询

### R-Tree（空间索引）

空间索引是MySAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少

### Full-text（全文索引）

是一种通过建立倒排索引，快速匹配文档的方式，类似于Lucene，Solr，ES

## B-Tree（多路平衡查找树）

以一颗最大度数（max-degree）为5（5阶）的B-Tree为例（每个节点最多存储4个key，5个指针）

## B+Tree

相对于B-Tree区别

1.所有的数据都会出现在叶子节点

2.叶子节点形成一个单向链表

3.MySQL索引数据结构对经典的B+Tree进行了优化，在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能

## Hahs

哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决

**特点**

1.hash索引只能用于对等比较（=，in），不支持范围查询

2.无法利用索引完成排序操作

3.查询效率高，通常只需要一次检索就可以了，效率通常高于B+Tree索引

**存储引擎支持**

在Mysql中，支持hash索引的是Memory引擎，而innoDB中具有自适应hash功能，hash索引是存储引擎根据B+Tree索引在指定条件下自动构建的

## 面试题

### 为什么innoDB存储引擎选择使用B+Tree索引结构？

1.相对于二叉树，层级更少，搜索效率高；

2.对于B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低

3.相对于hash索引，B+Tree支持范围匹配及排序

## 索引分类

**主键索引**：针对用于主键创建的索引，默认自动创建只能有一个   **关键字**  PRIMARY

**唯一索引**：避免同一个表中某数据列中值的重复，可以有多个  **关键字** UNIQUE

**常规索引**：快速定位特定数据，可以有多个

**全文索引**：全文索引查找的是文本中的关键词，而不是比较索引中的值，可以有多个  **关键字** FULLTEXT

### **在innoDB存储引擎中，根据索引的存储形式，又可以分为一下两种：**

**聚集索引**：将数据存储于索引放到了一块，索引结构的叶子节点保存了行数据，**必须有，而去只能有一个**

**二级索引**：将数据于索引分开存储，索引结构的叶子节点关联的是对应的主键，**可以存在多个**

**聚集索引选取规则**

1.如果存在主键，主键索引就是聚集索引

2.如果不存在主键索引，将使用第一个唯一（UNIQUE）索引作为聚集索引

3.如果表没有主键，或没有合适的唯一索引，则innoDB会自动生成一个rowid作为隐藏的聚集索引   

## SQL性能分析

### 慢查询日志

慢查询日志记录了所有执行时间超过指定参数（long_query_time,单位：秒，默认10秒）的所有SQL语句的日志。MySQL 的慢查询日志默认没有开启需要在MySql的配置文件（/ect/my.cof）中配置如下信息   

~~~sql
#开启MySQL慢日志查询开关
slow_query_log=1
#设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒就会视为慢查询，记录慢查询日志
long_query_time=2
~~~

**配置完毕后，通过一下指令重启MySQL服务器进行测试，查看慢日志文件中记录的信息/var/lib/mysql/localhost-show.log**      

### profile详情

show profiles 能够在做SQL忧患时帮助我们了解时间耗费到哪里去了。通过have_profiling参数，能够看到当前MySQL是否支持porfiling操作

 ~~~sql
select @@have_profiling;
 ~~~

 默认profiling是关闭的，可以通过set语句在session/global级别开启profiling；

~~~sql
set profiling=1；
~~~

执行一系列的业务SQL的操作，然后通过如下指令查看指令的执行耗时；

~~~sql
#查看每一条SQL的耗时基本情况
show profiles;

#查看指定query_id的SQL语句各个阶段的耗时情况
show profile for query query_id;

#查看指定query_id的SQL语句CPU的使用情况
show profile cpu for query query_id;
~~~

###  explain执行计划

EXPLAIN或者DESC命令获取MySQL如何执行SELECT语句的信息，包括在SELECT语句执行过程中表如何连接和连接的顺序

**语法**：直接在select语句之前加上关键字explain/desc

**EXPLAIN执行计划各字段含义：**

**id**：select查询的序列号，表示查询中执行select子句或者是操作表的顺序（id相同，执行顺序从上到下；id不同，值越大，越先执行）。

**select_type**：表示SELECT的类型，常见的取值有SIMPLE（简单表，即不使用表连接或者子查询），PRIMARY（主查询，即外层的查询），UNION（UNION中的第二个或者后面的查询语句），SUBQUERY（SELECT/WHERE之后包含了子查询）等

**type**：表示连接类型，性能由好到差的连接类型为NULL,system，const,eq_ref,ref,range,index,all.

**possible_key**:显示可能应用这张表上的索引，一个或多个。               

**key**：实际使用的索引，如果为NULL，则没有使用索引。

**key_len**：表示索引中使用的字节树，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好。

**rows**：MySQL认为必须要执行查询的行数，在innoDB引擎的表中，是一个估计值，可能并不总是准确的。

**filtered**：表示返回结果的行数占需读取行数的百分比，filtered的值越大越好

### 最左前缀法则

如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是从查询索引的最左列开始，并且不跳过索引中的列。如歌跳过某一列，索引将部分失效（后面的字段索引失效）         

### 范围查询

联合索引中，出现范围查询（>,<）范围查询的右侧索引失效

### 索引失效

**索引列运算**：不要在索引列上进行运算操作，索引将会失效

**字符串不加引号**：字符串类型字段使用时，不加引号，索引将失效

**模糊查询**：如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效

**or连接的条件**：用or分割的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。

**数据分布影响**：如果MySQL评估使用索引比全表更慢，则不使用索引

## 索引使用

### SQL提示

SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。

**语法**：

~~~sql
use index;    建议使用索引，MySQL内部会做权衡是否接受建议
ignore index； 忽略某个索引
force index；  强制指定使用某个索引
select * from 表名 use 索引名 where 条件
~~~

### 覆盖索引&回表查询

**覆盖索引**：尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到），减少select*。

**回表查询**：当使用二级索引查询不到所有需要的值时，会根据叶子节点的id进行回表查询

###    前缀索引

当字段类型为字符串（varchar,text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量磁盘io，影响查询效率，此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率

**语法**

~~~sql
create index 索引名 on 表名（字段名（截取多少位））


前缀长度：
可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是一，这是最好的索引选择性，性能也是最好的
例：
select count（distinct email）/ count(*) from 表名；
select count(distinct substring(email,1,5))/count(*) from 表名;
~~~

### 单列&联合索引

尽量使用联合索引，使用单列索引容易导致回表查询

###   索引设计原则

针对于数据量较大，且查询比较频繁的表建立索引

针对于常用做查询条件，排序，分组操作的字段建立索引

尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高

如果是字符串类型的字段，字段的长度较长，可以正对于字段的特点建造前缀索引

尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率

要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率

如果索引列不能存储null值，请在创键表时使用not null约束它。当优化器知道每列是否包含null值时，它可以更好地确定哪个索引最有效地用于查询

# SQL优化

## 插入数据

**insert优化**

1.批量插入 

2.手动提交事务

3.主键顺序插入

**大批量插入数据**：

如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令进行插入。操作如下

~~~sql
#客户端连接服务端时，加上参数 --local-infile
mysql --local-infile -uroot -p

#设置全局参数local_infile为1，开启从本地加载文件导入数据的开关
set global local_infile=1;

#执行load指令将准备好的数据，加载到表结构中
load data local infile '文件地址',into table 表名 fields terminated by ‘字段间的分割条件 例： ，’ lines terminated by '每条数据的分割条件 例：\n'
~~~

## 主键优化

**数据组织方式**：在innoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（index organized table IOT）。

**页分裂**：页可以为空，页可以填充一半，页可以填充100%。每个页包含了2-N行数据（如果一行数据多大，会行溢出），根据主键排列

**页合并**：当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录达到MERGE_THRESHOLD（默认为页的50%），innoDB会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用

**主键设计原则**

》满足业务欲求的情况下，尽量降低主键的长度

》插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键

》尽量不要使用UUID做主键或者是其他自然主键，如身份证号

》业务操作时，避免对主键的修改

### order  by优化

**Using filesort**：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲去sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫FileSort排序

**Using index**：通过有序索引顺序扫描直接返回有序数据，这种情况即为using index，不需要额外排序，操作效率高

 》根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。

》尽量使用覆盖索引

》多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）。

》如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size(默认256k)

### group by优化

》在分组操作时，可以通过索引来提高效率

》分组操作时，索引的使用也是满足最左前缀法则的

### limit优化

优化思路：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化

### count优化

》MyISAM引擎把一个表的总行数存在了磁盘上，因此执行count（*）的时候回直接返回这个数，效率很高

》innoDB引擎就麻烦了，它执行count（*）的时候，需要把数据一行一行地从引擎里面读出来，然后累积技术

**优化思路**：自己计数

**count的几种用法**

》count（主键）

 innoDB 引擎会遍历整张表，把每一行的主键id值都取出来，返回给服务层。服务层拿到主键后，直接按行进行累加（主键不可能为null）。

》count（字段）

没有not null约束：innoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，技数累加。

有not null约束：innoDB引擎会遍历整张表把每一行的字段值都取出来，返回服务层，直接按行进行累加

》count（1）

innoDB引擎遍历整张表，但不取值，服务层对于返回的每一行，放一个数字"1"进去，直接按行进行累加。

》count（*）

innoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加。

**按照效率排序的话，count(字段) < count(主键id)<count(1)≈count(*),所以尽量使用count(*).**

### update优化

innoDB的行锁是针对索引加的锁，不是针对记录加的锁，并且索引不能失效，否则会从行锁升级为表锁

# 面试题

## 什么是MVCC？

mvcc即多版本并发控制器，是对于隔离级别的实现，他有两个概念分别是当前读，快照读，当前读如，select for

update，insert，delete，update。执行这些语句的时候就会是当前读，因为我们需要保证数据的一致性问题会把当前最新的数据给拿出来，快照读，是mysql为了提高性能会在第一次select是查询后生成快照读，再次进行查询的话就会沿用上一次的快照读

