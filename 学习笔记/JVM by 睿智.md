

## 引言

## 什么是JVM

定义：

 Java Virtual Machine -java 的程序的运行环境（java二进制字节码的运行环境）

好处： 

1.一次编译到处运行

2.自动内存管理，垃圾回收机制

3.数组下标越界检查

4.多态

### 开发环境

JDK中包含的有JRE，开发工具，基础类库

JRE中包含JVM，基础类库

我们的java程序都是运行在JVM虚拟机中的

如果JDK加上我们的开发工具如IDE就可以开发我们JAVASE的程序

如果JDK加上我们的开发工具，应用服务器就可以开发我们的JAVAEE的程序

## 学习JVM有什么用？

1. 帮助面试
2. 理解底层的实现原理
3. 中高级程序员必备技能

## 常见的JVM

JVMK可以是一种规范，只要遵守这个规范，可以进行自己的实现。我学习的是基于hotspot的实现。



## 内存结构

内存结构概述

![1724204655239](C:\Users\mi11\AppData\Local\Temp\1724204655239.png)

###   类加载器

- 类加载器子系统股则从文件系统或网络中加载class文件，class文件在文件头有特定的文件标识
- ClassLoader只负责class文件的加载，不关心他是否可以运行。
- 加载的类信息存放于方法区的内存空间。

#### 类加载过程

1. 加载 

类加载器会去读取到我们的calss文件以流的方式加载到内存，利用getClassLoader来获取到类加载器，创建实例保存在内存当中。

2. 链接

验证（verify)

- 目的在于确保calss文件的字节流中的正确性，保证被加载类的正确性。
- 如文件格式验证，元数据验证，字节码验证，符号引用验证。

准备（prepare）

- 为变量分配内存和默认初始值
- 不包含用final关键字修饰的static
- 类变量会分配在方法区，而实例变量是随着对象分配到堆里

3. 初始化

- 初始化阶段就是执行类构造器方法<clinit>()的过程
- 此方法不需定义，是java编译器自动收集类中变量的赋值动作和静态代码块合并而来
- 构造器方法中指令按语句在源文件中出现的顺序执行
- <clinit>不同于构造器
- 若该类具有父类，JVM会保证在初始化该类前，讲父类初始化完成
- 每个类指挥初始化一次，在初始化时JVM会进行同步加锁。

#### 类加载器的分类

- 启动类加载器（引导类加载器， Bootstrap ClassLoader）
  - 这个类加载器使用C/C++来实现的，嵌套在JVM内部。
  - 它用来加载Java的核心库，用于提供JVM自身需要的类
  - 并不继承ClassLoader,没有父加载器
  - 加载扩展和应用程序类加载器，并指定未它们的父类加载器
  - 出于安全考虑，Bootstrap启动类加载器只加载包名为java,javax，sun等开头的类

- 扩展类加载器 
  - 派生于ClassLoader
  - 父类加载器为启动类加载器 
  - 从JDK安装目录的jre/lib/ext扩展目录下加载类库。

- 系统类加载器
  - 派生于CkassLoader
  - 父类加载器为扩展类加载器
  - 用于加载我们JAVA应用系统类库，如我们自己写的和引入的jar

- 自定义类加载器

  - 隔离加载类
  - 修改类加载方式
  - 扩展加载源
  - 防止源码泄露

   ### 双亲委派机制

   当我们需要加载类时，不会去立刻加载而是去委托他的父类加载器去加载这个对象。

  如果父类加载器还存在父类加载器，则继续向上委托，直到引导类加载器。

  父类加载器加载到了就返回，如父加载类加载不到时会再委托给子类加载器来加载对象。

  ![1724233401917](C:\Users\mi11\AppData\Local\Temp\1724233401917.png)

  优点：

  ​	避免类重复加载

  ​	保护程序安全，防止核心API被随意修改。

  沙箱安全保护机制

  ​	用于保护核心类不被篡改。如在本地写一个java.lang.String运行时就会异常

  ​	

  其他：

  - 在JVM中表示两个class对象是否为同一个类存在两个必要条件
    - 类的类名和包名必须一致
    - 加载这个类的Classloader必须相同。 



## 线程

- 线程是一个程序里的运行单元，JVM允许一个应用有多个线程并行的执行。
- 在Hotspot JVM每个线程都与操作系统的本地线程直接映射，当一个java线程准备好以后，此时一个操作系统的本地线程也同时创建，Java线程终止后，本地线程也会回收。
- 操作系统负责所有线程的安排调度到任何一个可用的CPU上，一旦本地线程初始化成功，它就会调用Java线程中的run方法。
- 当运行时出现了未捕获的异常时，会去判断则会先去判断是否为除了守护线程为最后一个普通线程，如果是则JVM退出

JVM系统线程

- 虚拟机线程： 
- 周期任务线程： 这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行
- GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持
- 编译线程： 这种线程在运行时会将字节码编译成本地代码。
- 信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。

## 运行时数据区

### 程序技术器

**定义:** Program  Counter Register 程序技术器（寄存器）

**作用**： 用于记住下一条JVM命令的执行地址

解释器执行的时候会去通过程序技术器去找下一行代码的执行地址，进行执行解释器会将jvm命令转换为机器码再到Cpu, 程序计数器调用的是硬件层面的寄存器 ，因为寄存器的读写性能比较好，这个记下一条指令的操作比较频繁****

**特点**：程序计数器是线程私有的，每个线程都有自己的程序计数器

不会存在内存溢出的，

**问题**

为什么需要PC寄存器？

因为有多个线程下CPU是交替执行的，当切换回来后CPU需要知道执行到哪里了，所以需要PC寄存器进行记录。

PC寄存器为什么会定义为线程私有？

为了能够正确的记录每个线程正在执行的当前字节码指令地址。因为如果多个线程共用一个PC寄存器会互相干扰，相互覆盖。

​	

### 虚拟机栈

**定义**：栈 -线程运行需要的内存空间，如栈的元素称为栈帧，栈帧- 每个方法运行时需要  的内存

每个线程运行所需要的空间就称为虚拟机栈

每个栈有多个栈帧组成，对应着每次调用方法所需要的空间

每个线程都只能有一个活动栈帧，而呢个栈帧就是正在执行的当前方法

Java虚拟机规范允许Java栈的大小是动态或固定不变的

**生命周期** ：生命周期和线程一致

**作用**：主管Java程序的运行，他保存方法的局部变量，部分结果，并参与方法的调用和返 回。

**栈帧的内部结构**

- 局部变量表
  - 定义为一个数字数组，主要用于存储方法参数和定义方法体内的局部变量，包含各类基本数据类型，对象引用，以及返回地址的类型。
  - 由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题
  - 局部变量表所需的容量大小是在编译器确定下来的，并保存在方法的Code属性的maxmum local variables数据项中。
  - 局部变量的基本单位为slot槽，并且可以重复利用
  - 补充说明
    - 在栈帧中，与性能调优关系最密切的部分就是局部变量表，在方法执行时，虚拟机使用局部变量完成方法的传递。
    - 局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表直接或间接引用的对象都不会回收。
- 操作数栈
  - 在方法执行过程中根据字节码指令，往栈中写入数据或提取数据，即入栈和出栈。
- 动态链接 （指向运行时常量池的方法引用）
  - 在Java源文件被编译到字节码文件时，所有的变量和方法引用都作为符号引用保存在class文件中的常量池里。比如：描述一个方法调用了另外的方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。
- 方法返回地址
  - 存放调用该方法的pc寄存器的值
  - 正常提出调用者的pc寄存器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。
- 附加信息
  -   栈帧中还允许携带与java虚拟机实现相关的一些附加信息，例如，对程序调试提供支持的信息。
  -   栈顶缓存技术：基于栈式架构的虚拟机所使用的零地址指令更紧凑，但完成一项任务时必然需要更多的入栈和出栈的操作指令，由于操作数时存在内存中的，频繁调用势必会影响执行速度。所以JVM设计者们提出了栈顶缓存，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读写次数，提升执行引擎的执行效率。

**问题辨析**:

**1.垃圾回收是否涉及栈内存 ？**    

总归来说是线程对于方法的调用进行弹栈就会释放，垃圾回收并不涉及栈内存

**2.栈内存分配的越大越好吗 ？**  	

栈内存分配的越大，只是能创建的栈帧更多效率不会有所提高，而且还影响线程数量

**3.方法内的局部变量是否线程安全？**	

局部变量是线程私有的不会出现线程安全，但是如果被static修饰会是共享变量如果不做保护措施那么线程就是不安全的

如果局部变量的作用范围是在本方法内，那么他就是线程安全的

如过局部变量引用了对象并跳出了本方法的作用范围，就需要考虑线程安全问题

**4.栈内存溢出**

栈内存溢出 StackOverFlow        常见问题： 方法递归导致， 循环调用导致

**5.线程运行诊断**

案例：cpu占用过多

定位：

先使用top指令定位哪个进程cpu使用过高

ps H -eo pid ，tid ，%cpu | grep进程id (用ps明亮进一步定位到是哪个线程引起的cpu使用率过高)

使用jstack 进程id

​	可以根据线程id找到有问题的线程进一步定位到代码的源码行号

迟迟得不到结果有可能就是发生死锁了，也可以根据jstack 进程id 一步步进行排除



### 本地方法栈

**什么是本地方法**

标识符native可以与所有其它的java标识符连用，但abstract除外。  

Native Method Stacks	(本地方法栈)

本地方法栈是对于我们java程序底层需要c或c++调用硬件，本地方法栈就是我们使用这些本地方法运行所需要的空间

### 堆

#### 核心概述

- 一个JVM示例只存在一个堆内存，堆也是Java内存管理的核心区域。
- Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是Jvm管理的最大一块内存空间。
- 堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。
- 所有线程共享Java堆，在这里还可以划分线程私有的缓冲区。
- 所有的对象实例以及数组都应该在运行时分配在对上。
- 数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或数组在堆中的位置。
- 在方法结束后，堆中的对象不会马上移除，仅在垃圾收集的时候才会被移除
- 堆，是GC执行垃圾回收的重点区域。

#### 内存细分

Java7以前堆内存分为：新生代+老年代+永久代

Java8之后堆内存分为：新生代+老年代+元空间

#### 堆大小设置

默认情况下堆空间的大小

最小值： 物理内存 /64

最大值：物理内存 / 4

开发中建议将堆内存最小和最大值设置为相同的值。

~~~bash
# 设置堆空间最小值
-Xms [size]
# 设置堆空间最大 值
-Xmx [size]
~~~

查看设置的参数

方式一：

~~~bash
jps

jstat -gc [进程id]
~~~

方式二

程序结束后打印Gc详情。

-XX:+PrintGCDetails

#### 新生代和老年代

- 设置新生代和老年代的比例，默认值是2

  ~~~bash
  #表示新生代占1，老年代占2。 1：2
  -XX:NewRatio= 2 
  ~~~

  

- 在HotSpot中，Edan空间和另外两个Survivor空间缺省所占的比例是8:1:1

- 当然开发人员可以通过选项 "-XX:SurvivorRatio " 调整这个空间比例，比如

  ~~~bash
  -XX:SurvivorRatio = 8
  ~~~

- 几乎所有的Java对象都是在Eden区被new出来的。

- 绝大部分Java对象的销毁都在新生代进行了。

- 可以使用选项”-Xmn“设置新生代最大内存大小

#### 堆空间对象分配过程

1. new的对象先放伊甸园区。此区有大小限制。
2. 当伊甸园的空间填满时，程序又需要创建新的对象,Jvm的垃圾回收器将对伊甸园区进行垃圾回收，将伊甸园区中不在被被其他对象所引用的对象进行销毁。再加载新的对象到伊甸园区。
3. 然后将伊甸园中剩余的对象移动到幸存者0区。
4. 如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，没有回收，就会返到幸存者一区。
5. 如果再次经历垃圾回收，此时会重新方回幸存者0区，以此循环。
6. 当垃圾回收次数到达阈值时就会进入老年区，默认为15次，可以自行设置。

~~~bash
-XX:MaxTenuringThreshold=<N>
~~~

总结：

- 针对幸存者区，复制之后有交换，谁空谁是to
- 垃圾回收频繁发生再新生区，很少在老年区收集。

#### GC策略触发条件

**年轻代（Minor GC）**

- 当年轻代空间不足时，就会触发Minor GC，这里的年轻代指的是Eden满，Survivor满不会引发GC。
- 因为Java对象大多都具备朝生夕死的特性，所以Minor GC非常频繁，一般回收速度也比较块。这一定义既清晰又易于理解。
- Minor GC饮法STW，暂停其他用户的线程，等待垃圾回收结束，用户线程才能恢复运行。

**老年代（Major GC/Full GC）**

- 出现Major GC,经常会伴随至少以此的Minor GC,也就是在老年代空间不足时，会先尝试触发Minor GC,如果之后空间还不足，则触发Major GC.
- Major GC速度一般会比Minor GC慢10倍以上，STW时间更长
- 如果Major GC 后  ，内存还不足，就会报OOM了

#### 内存分配策略

- 优先分配到Eden
- 大对象直接分配到老年代，尽量避免程序中出现过多的大对象。
- 长期存活的对象分配到老年代
- 动态对象年龄判断，如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄.
- 空间分配担保

#### 对象分配过程：TLAB

什么是TLAB

- 从内存模型而不是垃圾收集的角度，堆Eden区域继续进行划分，Jvm为每个线程分配了一个私有缓存区域，他包含在eden区内。

- 多线程同时分配内存时，使用TLAB可以避免一系列非线程安全问题，同时还能够提升内存分配的吞吐量。

- 所有OpenJDK衍生出来的JVM都提供了TLAB的设计。

- 尽管不是所有的对象实例都能够存在TLAB中，但JVM确实将TLAB作为内存分配的首选。

- 在程序中，可以通过“ -XX:UseTLAB ”设置开启TLAB空间（默认开启）

- 默认情况下TLAB空间内存非常小，仅占有整个eden空间的1%。但我们可以通过以下命令来设置百分比大小。

  ~~~bash
  -xx:TLABWasteTargetPercent
  ~~~

- 一旦对象在TLAB空间分配失败时，JVM就会尝试通过使用加锁机制确保数据操作的原子性，后直接在eden空间中分配内存。



#### 堆空间的参数设置

~~~bash
#查看所有参数的默认初始值
-XX:+PrintDlagsInitial
#查看所有参数的最终值
-XX:+PrintDlagsFinal
#初始堆空间内存(默认为物理内存的1/64)
-Xms
#最大堆空间内存(默认为物理内存的1/4)
-Xmx
#设置新生代的大小（初始值及最大值）
-Xmn
#配置新生代与老年代在堆结构的占比
-XX:NewRatio
#设置新生代中Eden和survivor空间的比例
-XX:SurvivorRatio
#设置新生代垃圾的最大年龄
-XX:MaxTenuringThreshold
#输出详细的GC处理日志
-XX:+PrintGCDetails
#是否设置空间分配担保
-XX:HandlePromotionFailure
#查询运行中进程某个参数的指令
jinfo -flag SurvivorRatio 进程id
~~~

#### 逃逸分析

​	这是一种可以有效减少Java程序中同步负载和内存堆分配压力的算法，通过该算法计算出可以进行栈上分配的对象，减少GC。

​	当对象可以再方法外访问时这个对象就是逃逸对象，若对象只会在内部使用没有逃逸，就可以进行栈上分配。

​	所以在平时写代码时能用局部对象就用局部对象。

Heap   （堆）

**定义：**

通过new关键字创建出来的对象都会到堆空间内

堆里面的对象都是线程共享的，所以需要考虑到线程安全问题

有垃圾回收机制

**内存溢出问题**

对象不断创建最后导致堆内存空间不足导致溢出，

### 方法区

#### 栈，堆，方法区关系

#### 方法区基本理解

方法区可以看作是一块独立于Java堆的内存空间 

- 方法区与Java堆一样，是各个线程共享的内存区域。
- 方法区在JVM启动的时候被创建，并且他的实际的物理内存和Java区一样可以是不连续的。
- 方法区大小，跟堆空间一样，可以选择固定大小或者可扩展
- 方法区的大小决定了系统可以保存多少个类，当方法区移除会抛出OutOfMemoryError： Metaspace
- 关闭JVM就会释放这个区域的内存。

#### 方法区的演进

在JVM7当中方法区又被称为永久代，是存在与虚拟机内部的，因为用的是JVM的内存空间大小有所限制更容易出现OOM，在JVM8以后撇弃了永久代使用元空间来进行替代，元空间使用的是本地内存可分配的空间更大，OOM的概率更小。

#### 设置方法区的大小

 ~~~bash
#JDK7及之前
-XX:PremSize=[size]   --XX:MaxPremSize=[size]
#JDK8之后
-XX:MetaSpaceSize=[size] -XX:MaxMetaSpaceSize=[size]
 ~~~

-XX:MetaSpaceSize：设置元空间大小，对应一个64位的服务器端JVM来说，他的默认值位21MB，这就是初始的最高水平线，当使用超过这个水平线是就会触发FullGC,回收掉不用的类和加载器，然后根据释放后的元空间大小再重置这个最高水平线。如果初始的高水平线设置过低，可能会频发触发GC，所以建议给-XX:MetaSpaceSize设置一个较高的值。

#### 如何解决OOM 

​	通过Jconsloe等工具dump出堆的内存快照，重点是确认内存的对象是否必要也就是是否内存泄露了，如果是内存泄漏就需要找到泄露对象的引用链并将其断开。如果不存在内存泄漏，就检查虚拟机堆参数查看是否还可以调大，聪慧代码检查，是否有对象生命周期过长，尝试减少程序运行期的消耗。

#### 方法区的内存结构

​	它用于存储已被虚拟机加载的类型信息，常量，静态变量，即时编译器编译后的代码缓存等。

常量池

​	常量池可以看作一张表，虚拟机指令根据这张常量表找到要执行的类名，方法名，参数类型，字面量等类型。

####  方法区的垃圾回收

方法区的垃圾回收在java虚拟机规范中并没有明确指出必须实现。垃圾回收主要回收常量池中废弃的常量和不再使用的类型。

### **堆内存诊断**

1.jps   //查看当前系统中有哪些进程

2.jmap        //查看堆内存占用情况 -heap 进程ID

3.jconsole   //可以查看堆类线程cpu信息的可视化页面 

4.jvisualvm   //可以查看堆类线程cpu这类的可视化JVM虚拟机