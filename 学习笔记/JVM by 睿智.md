#### JVM by 睿智
## 引言

## 什么是JVM

定义：

 Java Virtual Machine -java 的程序的运行环境（java二进制字节码的运行环境）

好处： 

1.一次编译到处运行

2.自动内存管理，垃圾回收机制

3.数组下标越界检查

4.多态

### 开发环境

JDK中包含的有JRE，开发工具，基础类库

JRE中包含JVM，基础类库

我们的java程序都是运行在JVM虚拟机中的

如果JDK加上我们的开发工具如IDE就可以开发我们JAVASE的程序

如果JDK加上我们的开发工具，应用服务器就可以开发我们的JAVAEE的程序

## 学习JVM有什么用？

1. 帮助面试
2. 理解底层的实现原理
3. 中高级程序员必备技能

## 常见的JVM

JVMK可以是一种规范，只要遵守这个规范，可以进行自己的实现。我学习的是基于hotspot的实现。

## 学习路线

![1677245795337](C:\Users\mi11\AppData\Local\Temp\1677245795337.png)

大概流程是，先将代码编译成。class二进制文件，通过类加载器加载要JVM中由解释器逐行执行，对于频繁使用的方法会使用即时编译器作为优化。

# 内存结构

1. ### 程序技术器

   **定义:** Program  Counter Register 程序技术器（寄存器）

   **作用**： 用于记住下一条JVM命令的执行地址

   解释器执行的时候会去通过程序技术器去找下一行代码的执行地址，进行执行解释器会将jvm命令转换为机器码再到Cpu, 程序计数器调用的是硬件层面的寄存器 ，因为寄存器的读写性能比较好，这个记下一条指令的操作比较频繁****

   **特点**：程序计数器是线程私有的，每个线程都有自己的程序计数器

   不会存在内存溢出的，

   ​	

2. ### 虚拟机栈

   **定义**：栈 -线程运行需要的内存空间，如栈的元素称为栈帧，栈帧- 每个方法运行时需要  的内存

   每个线程运行所需要的空间就称为虚拟机栈

   每个栈有多个栈帧组成，对应着每次调用方法所需要的空间

   每个线程都只能有一个活动栈帧，而呢个栈帧就是正在执行的当前方法

   **问题辨析**:

   **1.垃圾回收是否涉及栈内存 ？**    

   总归来说是线程对于方法的调用进行弹栈就会释放，垃圾回收并不涉及栈内存

   **2.栈内存分配的越大越好吗 ？**  	

   栈内存分配的越大，只是能创建的栈帧更多效率不会有所提高，而且还影响线程数量

   **3.方法内的局部变量是否线程安全？**	

   局部变量是线程私有的不会出现线程安全，但是如果被static修饰会是共享变量如果不做保护措施那么线程就是不安全的

   如果局部变量的作用范围是在本方法内，那么他就是线程安全的

   如过局部变量引用了对象并跳出了本方法的作用范围，就需要考虑线程安全问题

   **4.栈内存溢出**

   栈内存溢出 StackOverFlow        常见问题： 方法递归导致， 循环调用导致

   **5.线程运行诊断**

   案例：cpu占用过多

   定位：

   先使用top指令定位哪个进程cpu使用过高

   ps H -eo pid ，tid ，%cpu | grep进程id (用ps明亮进一步定位到是哪个线程引起的cpu使用率过高)

   使用jstack 进程id

   ​	可以根据线程id找到有问题的线程进一步定位到代码的源码行号

   迟迟得不到结果有可能就是发生死锁了，也可以根据jstack 进程id 一步步进行排除

   

3. ### 本地方法栈

   Native Method Stacks	(本地方法栈)

   本地方法栈是对于我们java程序底层需要c或c++调用硬件，本地方法栈就是我们使用这些本地方法运行所需要的空间

   

4. ### 堆

   Heap   （堆）

   **定义：**

   通过new关键字创建出来的对象都会到堆空间内

   堆里面的对象都是线程共享的，所以需要考虑到线程安全问题

   有垃圾回收机制

   **内存溢出问题**

   对象不断创建最后导致堆内存空间不足导致溢出，

   ### **堆内存诊断**

   1.jps   //查看当前系统中有哪些进程

   2.jmap        //查看堆内存占用情况 -heap 进程ID

   3.jconsole   //可以查看堆类线程cpu信息的可视化页面

   4.jvisualvm   //可以查看堆类线程cpu这类的可视化JVM虚拟机